package com.github.leodan11.customview.textfield

import android.annotation.SuppressLint
import android.app.AlertDialog
import android.content.Context
import android.content.DialogInterface
import android.content.res.ColorStateList
import android.content.res.Resources
import android.content.res.Resources.NotFoundException
import android.database.DataSetObserver
import android.graphics.PorterDuff
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Parcel
import android.os.Parcelable
import android.text.InputType
import android.util.AttributeSet
import android.util.TypedValue
import android.view.AbsSavedState
import android.view.SoundEffectConstants
import android.view.View
import android.view.View.OnFocusChangeListener
import android.view.ViewGroup
import android.view.ViewTreeObserver
import android.view.WindowManager
import android.view.accessibility.AccessibilityEvent
import android.widget.AdapterView
import android.widget.ListAdapter
import android.widget.ListView
import android.widget.SpinnerAdapter
import androidx.annotation.AttrRes
import androidx.annotation.ColorInt
import androidx.annotation.ColorRes
import androidx.annotation.DrawableRes
import androidx.annotation.RequiresApi
import androidx.appcompat.widget.ListPopupWindow
import androidx.appcompat.widget.ThemedSpinnerAdapter
import androidx.core.content.res.ResourcesCompat
import androidx.core.graphics.drawable.DrawableCompat
import androidx.core.text.TextUtilsCompat
import com.google.android.material.bottomsheet.BottomSheetDialog
import com.google.android.material.textfield.TextInputEditText
import com.google.android.material.textfield.TextInputLayout
import java.util.Locale

/**
 * Layout which wraps an [TextInputEditText] to show a floating label when the hint is hidden due to
 * the user inputting text.
 *
 * @see [TextInputLayout]
 */
@SuppressLint("PrivateResource")
class MaterialSpinner @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    mode: Int = MODE_DROPDOWN
) : TextInputLayout(context, attrs) {

    companion object {
        /**
         * Represents an invalid position.
         * All valid positions are in the range 0 to 1 less than the number of items in the current
         * adapter.
         */
        const val INVALID_POSITION = -1

        /**
         * Use a dialog window for selecting spinner options.
         */
        const val MODE_DIALOG = 0

        /**
         * Use a dropdown anchored to the Spinner for selecting spinner options.
         */
        const val MODE_DROPDOWN = 1

        /**
         * Use a bottom sheet dialog window for selecting spinner options.
         */
        const val MODE_BOTTOM_SHEET = 2
    }

    private val colorStateList: ColorStateList

    /**
     * The view that will display the available list of choices.
     */
    private val popup: SpinnerPopup

    /**
     * The view that will display the selected item.
     */
    private val editText = TextInputEditText(getContext())

    /**
     * Extended [android.widget.Adapter] that is the bridge between this Spinner and its data.
     */
    var adapter: SpinnerAdapter? = null
        set(value) {
            field = DropDownAdapter(value, context.theme).also {
                popup.setAdapter(it)
            }
        }

    /**
     * The listener that receives notifications when an item is selected.
     */
    var onItemSelectedListener: OnItemSelectedListener? = null

    /**
     * The listener that receives notifications when an item is clicked.
     */
    var onItemClickListener: OnItemClickListener? = null

    /**
     * The layout direction of this view.
     * {@link #LAYOUT_DIRECTION_RTL} if the layout direction is RTL.
     * {@link #LAYOUT_DIRECTION_LTR} if the layout direction is not RTL.
     */
    private var direction =
        if (isLayoutRtl()) View.LAYOUT_DIRECTION_RTL else View.LAYOUT_DIRECTION_LTR

    /**
     * The currently selected item.
     */
    var selection = INVALID_POSITION
        set(value) {
            field = value
            adapter?.apply {
                if (value in 0 until count) {
                    editText.setText(
                        when (val item = getItem(value) ?: "") {
                            is CharSequence -> item
                            else -> item.toString()
                        }
                    )
                    onItemSelectedListener?.onItemSelected(
                        this@MaterialSpinner,
                        null,
                        value,
                        getItemId(value)
                    )
                } else {
                    editText.setText("")
                    onItemSelectedListener?.onNothingSelected(this@MaterialSpinner)
                }
            }
        }

    /**
     * Sets the [prompt] to display when the dialog is shown.
     *
     * @return The prompt to display when the dialog is shown.
     */
    var prompt: CharSequence?
        set(value) {
            popup.setPromptText(value)
        }
        get() = popup.getPrompt()

    /**
     * @return The data corresponding to the currently selected item, or null if there is nothing
     * selected.
     */
    val selectedItem: Any?
        get() = popup.getItem(selection)

    /**
     * @return The id corresponding to the currently selected item, or {@link #INVALID_ROW_ID} if
     * nothing is selected.
     */
    val selectedItemId: Long
        get() = popup.getItemId(selection)

    init {
        context.obtainStyledAttributes(attrs, R.styleable.MaterialSpinner).run {
            getInt(R.styleable.MaterialSpinner_android_gravity, -1).let {
                if (it > -1) {
                    gravity = it
                    editText.gravity = it
                }
            }
            editText.isEnabled =
                getBoolean(R.styleable.MaterialSpinner_android_enabled, editText.isEnabled)
            editText.isFocusable =
                getBoolean(R.styleable.MaterialSpinner_android_focusable, editText.isFocusable)
            editText.isFocusableInTouchMode = getBoolean(
                R.styleable.MaterialSpinner_android_focusableInTouchMode,
                editText.isFocusableInTouchMode
            )
            getColorStateList(R.styleable.MaterialSpinner_android_textColor)?.let {
                editText.setTextColor(it)
            }
            getDimensionPixelSize(
                R.styleable.MaterialSpinner_android_textSize,
                -1
            ).let { if (it > 0) editText.textSize = it.toFloat() }
            getText(R.styleable.MaterialSpinner_android_text)?.let {
                // Allow text in debug mode for preview purposes.
                if (isInEditMode) {
                    editText.setText(it)
                } else {
                    throw RuntimeException(
                        "Don't set text directly." +
                                "You probably want setSelection instead."
                    )
                }
            }
            popup = when (getInt(R.styleable.MaterialSpinner_spinnerMode, mode)) {
                MODE_DIALOG -> {
                    DialogPopup(context, getString(R.styleable.MaterialSpinner_android_prompt))
                }

                MODE_BOTTOM_SHEET -> {
                    BottomSheetPopup(context, getString(R.styleable.MaterialSpinner_android_prompt))
                }

                else -> {
                    DropdownPopup(context, attrs)
                }
            }

            // Create the color state list.
            //noinspection Recycle
            colorStateList = context.obtainStyledAttributes(
                attrs,
                intArrayOf(android.R.attr.colorPrimary)
            ).run {
                val activated = getColor(0, 0)
                val normal =
                    getContext().getColorCompat(getContext().customResolverResourceId(android.R.attr.colorControlNormal))
                recycle()
                ColorStateList(
                    arrayOf(
                        intArrayOf(android.R.attr.state_pressed),
                        intArrayOf(android.R.attr.state_focused),
                        intArrayOf()
                    ), intArrayOf(activated, activated, normal)
                )
            }
            // Set the arrow and properly tint it.
            getContext().getDrawableCompat(
                getResourceId(
                    R.styleable.MaterialSpinner_android_src,
                    getResourceId(
                        R.styleable.MaterialSpinner_srcCompat,
                        R.drawable.ic_spinner_drawable
                    )
                ), getContext().theme
            ).let {
                setDrawable(it)
            }

            recycle()
        }

        this.addView(editText, LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT))

        popup.setOnDismissListener(object : SpinnerPopup.OnDismissListener {
            override fun onDismiss() {
                editText.clearFocus()
            }
        })

        // Disable input.
        editText.maxLines = 1
        editText.inputType = InputType.TYPE_NULL
        editText.imeOptions = WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN

        editText.setOnClickListener {
            popup.show(selection)
        }

        editText.onFocusChangeListener.let {
            editText.onFocusChangeListener = OnFocusChangeListener { v, hasFocus ->
                v.handler?.post {
                    if (hasFocus) {
                        v.performClick()
                    }
                    it?.onFocusChange(v, hasFocus)
                    onFocusChangeListener?.onFocusChange(this, hasFocus)
                }
            }
        }
    }

    fun setDrawable(drawable: Drawable?, applyTint: Boolean = true) {
        val delta = (editText.paddingBottom - editText.paddingTop) / 2
        drawable?.let { DrawableCompat.wrap(drawable) }?.apply {
            setBounds(0, 0, intrinsicWidth, intrinsicHeight)
            if (applyTint) {
                DrawableCompat.setTintList(this, colorStateList)
                DrawableCompat.setTintMode(this, PorterDuff.Mode.SRC_IN)
            }
        }.let {
            if (isLayoutRtl()) {
                Pair(it, null)
            } else {
                Pair(null, it)
            }
        }.let { (left, right) ->
            editText.setCompoundDrawablesWithIntrinsicBounds(left, null, right, null)
            editText.compoundDrawables.forEach {
                it?.run {
                    bounds = copyBounds().apply {
                        top += delta
                        bottom += delta
                    }
                }
            }
        }
    }

    override fun setOnClickListener(l: OnClickListener?) {
        throw RuntimeException(
            "Don't call setOnClickListener." +
                    "You probably want setOnItemClickListener instead."
        )
    }

    /**
     * Set whether this view can receive the focus.
     * Setting this to false will also ensure that this view is not focusable in touch mode.
     *
     * @param [focusable] If true, this view can receive the focus.
     *
     * @see [android.view.View.setFocusableInTouchMode]
     * @see [android.view.View.setFocusable]
     * @attr ref android.R.styleable#View_focusable
     */
    override fun setFocusable(focusable: Boolean) {
        editText.isFocusable = focusable
        super.setFocusable(focusable)
    }

    /**
     * Set whether this view can receive focus while in touch mode.
     * Setting this to true will also ensure that this view is focusable.
     *
     * @param [focusableInTouchMode] If true, this view can receive the focus while in touch mode.
     *
     * @see [android.view.View.setFocusable]
     * @attr ref android.R.styleable#View_focusableInTouchMode
     */
    override fun setFocusableInTouchMode(focusableInTouchMode: Boolean) {
        editText.isFocusableInTouchMode = focusableInTouchMode
        super.setFocusableInTouchMode(focusableInTouchMode)
    }

    /**
     * @see [android.view.View.onRtlPropertiesChanged]
     */
    override fun onRtlPropertiesChanged(layoutDirection: Int) {
        if (direction != layoutDirection) {
            direction = layoutDirection
            editText.compoundDrawables.let {
                editText.setCompoundDrawablesWithIntrinsicBounds(it[2], null, it[0], null)
            }
        }
        super.onRtlPropertiesChanged(layoutDirection)
    }

    @SuppressLint("ClickableViewAccessibility")
    override fun performClick(): Boolean {
        return requestFocus()
    }

    /**
     * Call the OnItemClickListener, if it is defined.
     * Performs all normal actions associated with clicking: reporting accessibility event, playing
     * a sound, etc.
     *
     * @param [view] The view within the adapter that was clicked.
     * @param [position] The position of the view in the adapter.
     * @param [id] The row id of the item that was clicked.
     * @return True if there was an assigned OnItemClickListener that was called, false otherwise is
     * returned.
     */
    fun performItemClick(view: View?, position: Int, id: Long): Boolean {
        return run {
            onItemClickListener?.let {
                playSoundEffect(SoundEffectConstants.CLICK)
                it.onItemClick(this@MaterialSpinner, view, position, id)
                true
            } ?: false
        }.also {
            view?.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED)
        }
    }

    /**
     * Sets the prompt to display when the dialog is shown.
     *
     * @param [promptId] the resource ID of the prompt to display when the dialog is shown.
     */
    fun setPromptId(promptId: Int) {
        prompt = context.getText(promptId)
    }

    override fun onSaveInstanceState(): Parcelable {
        return SavedState(super.onSaveInstanceState()!!).apply {
            this.selection = this@MaterialSpinner.selection
            this.isShowingPopup = this@MaterialSpinner.popup.isShowing()
        }
    }

    override fun onRestoreInstanceState(state: Parcelable?) {
        when (state) {
            is SavedState -> {
                super.onRestoreInstanceState(state.superState)
                selection = state.selection
                if (state.isShowingPopup) {
                    viewTreeObserver?.let {
                        it.addOnGlobalLayoutListener(object :
                            ViewTreeObserver.OnGlobalLayoutListener {
                            override fun onGlobalLayout() {
                                if (!popup.isShowing()) {
                                    requestFocus()
                                }
                                it.removeOnGlobalLayoutListener(this)
                            }
                        })
                    }
                }
            }

            else -> super.onRestoreInstanceState(state)
        }
    }

    override fun onDetachedFromWindow() {
        super.onDetachedFromWindow()
        if (popup.isShowing()) {
            popup.dismiss()
        }
    }

    /**
     * Returns if this view layout should be in a RTL direction.
     * @return True if is RTL, false otherwise .
     */
    private fun isLayoutRtl(): Boolean {
        return Locale.getDefault().isLayoutRtl()
    }

    /**
     * Returns if this Locale direction is RTL.
     * @return True if is RTL, false otherwise .
     */
    private fun Locale.isLayoutRtl(): Boolean {
        return TextUtilsCompat.getLayoutDirectionFromLocale(this) == View.LAYOUT_DIRECTION_RTL
    }

    /**
     * @see [ResourcesCompat.getDrawable]
     */
    private fun Context.getDrawableCompat(
        @DrawableRes id: Int,
        theme: Resources.Theme?
    ): Drawable? {
        return resources.getDrawableCompat(id, theme)
    }

    /**
     * @see [ResourcesCompat.getDrawable]
     */
    @Throws(NotFoundException::class)
    private fun Resources.getDrawableCompat(
        @DrawableRes id: Int,
        theme: Resources.Theme?
    ): Drawable? {
        return ResourcesCompat.getDrawable(this, id, theme)?.let { DrawableCompat.wrap(it) }
    }

    @Throws(NotFoundException::class)
    private fun Context.customResolverResourceId(@AttrRes idAttrRes: Int): Int {
        val typedValue = TypedValue()
        this.theme.resolveAttribute(idAttrRes, typedValue, true)
        return typedValue.resourceId
    }

    /**
     * Returns a themed color integer associated with a particular resource ID.
     * If the resource holds a complex [android.content.res.ColorStateList], then the default color from the set is returned.
     *
     * @param id The desired resource identifier, as generated by the aapt tool.
     *           This integer encodes the package, type, and resource entry.
     *           The value 0 is an invalid identifier.
     *
     * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
     *
     * @return A single color value in the form 0xAARRGGBB.
     */
    @Throws(NotFoundException::class)
    @ColorInt
    fun Context.getColorCompat(@ColorRes id: Int): Int {
        return if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP_MR1) {
            resources.getColor(id, theme)
        } else {
            @Suppress("DEPRECATION") resources.getColor(id)
        }
    }

    private inner class DialogPopup(
        val context: Context,
        private var prompt: CharSequence? = null
    ) : DialogInterface.OnClickListener, SpinnerPopup {

        private var popup: AlertDialog? = null
        private var adapter: ListAdapter? = null
        private var listener: SpinnerPopup.OnDismissListener? = null

        override fun setAdapter(adapter: ListAdapter?) {
            this.adapter = adapter
        }

        override fun setPromptText(hintText: CharSequence?) {
            prompt = hintText
        }

        override fun getPrompt(): CharSequence? {
            return prompt
        }

        override fun show(position: Int) {
            if (adapter == null) {
                return
            }

            popup = adapter?.let { adapter ->
                AlertDialog.Builder(context).let { builder ->
                    prompt?.let { prompt ->
                        builder.setTitle(prompt)
                    }
                    builder.setSingleChoiceItems(adapter, position, this).create().apply {
                        popup?.listView?.let {
                            it.textDirection = textDirection
                            it.textAlignment = textAlignment
                        }
                        setOnDismissListener { listener?.onDismiss() }
                    }
                }.also {
                    it.show()
                }
            }
        }

        override fun dismiss() {
            popup?.dismiss()
        }

        override fun onClick(dialog: DialogInterface, which: Int) {
            this@MaterialSpinner.selection = which
            onItemClickListener?.let {
                this@MaterialSpinner.performItemClick(null, which, adapter?.getItemId(which) ?: 0L)
            }
            popup?.dismiss()
        }

        override fun setOnDismissListener(listener: SpinnerPopup.OnDismissListener?) {
            this.listener = listener
        }

        override fun getItem(position: Int): Any? {
            return adapter?.getItem(position)
        }

        override fun getItemId(position: Int): Long {
            return adapter?.getItemId(position) ?: INVALID_POSITION.toLong()
        }

        override fun isShowing() = popup?.isShowing == true
    }

    /**
     * A PopupWindow that anchors itself to a host view and displays a list of choices.
     */
    @SuppressLint("RestrictedApi")
    private inner class DropdownPopup(context: Context, attrs: AttributeSet?) :
        ListPopupWindow(context, attrs), SpinnerPopup {

        init {
            inputMethodMode = INPUT_METHOD_NOT_NEEDED
            anchorView = this@MaterialSpinner
            isModal = true
            promptPosition = POSITION_PROMPT_ABOVE
            setOverlapAnchor(false)

            @Suppress("UNUSED_ANONYMOUS_PARAMETER")
            setOnItemClickListener { parent, v, position, id ->
                this@MaterialSpinner.selection = position
                onItemClickListener?.let {
                    this@MaterialSpinner.performItemClick(
                        v,
                        position,
                        adapter?.getItemId(position) ?: 0L
                    )
                }
                dismiss()
            }
        }

        override fun show(position: Int) {
            super.show()
            listView?.let {
                it.choiceMode = ListView.CHOICE_MODE_SINGLE
                it.textDirection = textDirection
                it.textAlignment = textAlignment
            }
            setSelection(position)
        }

        override fun setOnDismissListener(listener: SpinnerPopup.OnDismissListener?) {
            super.setOnDismissListener {
                listener?.onDismiss()
            }
        }

        override fun setPromptText(hintText: CharSequence?) = Unit

        override fun getPrompt(): CharSequence? {
            return null
        }

        override fun getItem(position: Int): Any? {
            return adapter?.getItem(position)
        }

        override fun getItemId(position: Int): Long {
            return adapter?.getItemId(position) ?: INVALID_POSITION.toLong()
        }
    }

    private inner class BottomSheetPopup(
        val context: Context,
        private var prompt: CharSequence? = null
    ) : SpinnerPopup {

        private var popup: BottomSheetDialog? = null
        private var adapter: ListAdapter? = null
        private var listener: SpinnerPopup.OnDismissListener? = null

        override fun setAdapter(adapter: ListAdapter?) {
            this.adapter = adapter
        }

        override fun setPromptText(hintText: CharSequence?) {
            prompt = hintText
        }

        override fun getPrompt(): CharSequence? {
            return prompt
        }

        override fun show(position: Int) {
            if (adapter == null) {
                return
            }

            popup = BottomSheetDialog(context).apply {
                prompt?.let { prompt ->
                    setTitle(prompt)
                }
                setContentView(ListView(context).apply {
                    adapter = this@BottomSheetPopup.adapter

                    @Suppress("UNUSED_ANONYMOUS_PARAMETER")
                    onItemClickListener =
                        AdapterView.OnItemClickListener { parent, v, position, id ->
                            this@MaterialSpinner.selection = position
                            onItemClickListener?.let {
                                this@MaterialSpinner.performItemClick(
                                    v,
                                    position,
                                    adapter?.getItemId(position) ?: 0L
                                )
                            }
                            dismiss()
                        }
                })
                textDirection = this@MaterialSpinner.textDirection
                textAlignment = this@MaterialSpinner.textAlignment
                setOnDismissListener { listener?.onDismiss() }
            }.also {
                it.show()
            }
        }

        override fun dismiss() {
            popup?.dismiss()
        }

        override fun setOnDismissListener(listener: SpinnerPopup.OnDismissListener?) {
            this.listener = listener
        }

        override fun getItem(position: Int): Any? {
            return adapter?.getItem(position)
        }

        override fun getItemId(position: Int): Long {
            return adapter?.getItemId(position) ?: INVALID_POSITION.toLong()
        }

        override fun isShowing() = popup?.isShowing == true
    }

    /**
     * Creates a new ListAdapter wrapper for the specified adapter.
     *
     * @param [adapter] The SpinnerAdapter to transform into a ListAdapter.
     * @param [dropDownTheme] The theme against which to inflate drop-down views, may be {@null}
     * to use default theme.
     */
    private inner class DropDownAdapter(
        private val adapter: SpinnerAdapter?,
        dropDownTheme: Resources.Theme?
    ) : ListAdapter, SpinnerAdapter {

        private val listAdapter: ListAdapter? = when (val it = adapter) {
            is ListAdapter -> it
            else -> null
        }

        init {

            dropDownTheme?.let {
                when (adapter) {
                    is ThemedSpinnerAdapter -> {
                        if (adapter.dropDownViewTheme != it) {
                            adapter.dropDownViewTheme = it
                        }
                    }

                    else -> {
                        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP_MR1) {
                            when (adapter) {
                                is android.widget.ThemedSpinnerAdapter -> {
                                    if (adapter.dropDownViewTheme == null) {
                                        adapter.dropDownViewTheme = it
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        override fun getCount(): Int {
            return adapter?.count ?: 0
        }

        override fun getItem(position: Int): Any? {
            return adapter?.let {
                if (position > INVALID_POSITION && position < it.count) it.getItem(
                    position
                ) else null
            }
        }

        override fun getItemId(position: Int): Long {
            return adapter?.getItemId(position) ?: INVALID_POSITION.toLong()
        }

        override fun getView(position: Int, convertView: View?, parent: ViewGroup): View? {
            return getDropDownView(position, convertView, parent)
        }

        override fun getDropDownView(position: Int, convertView: View?, parent: ViewGroup): View? {
            return adapter?.getDropDownView(position, convertView, parent)
        }

        override fun hasStableIds(): Boolean {
            return adapter?.hasStableIds() ?: false
        }

        override fun registerDataSetObserver(observer: DataSetObserver) {
            adapter?.registerDataSetObserver(observer)
        }

        override fun unregisterDataSetObserver(observer: DataSetObserver) {
            adapter?.unregisterDataSetObserver(observer)
        }

        /**
         * If the wrapped SpinnerAdapter is also a ListAdapter, delegate this call. Otherwise,
         * return true.
         */
        override fun areAllItemsEnabled(): Boolean {
            return listAdapter?.areAllItemsEnabled() ?: true
        }

        /**
         * If the wrapped SpinnerAdapter is also a ListAdapter, delegate this call. Otherwise,
         * return true.
         */
        override fun isEnabled(position: Int): Boolean {
            return listAdapter?.isEnabled(position) ?: true
        }

        override fun getItemViewType(position: Int): Int {
            return 0
        }

        override fun getViewTypeCount(): Int {
            return 1
        }

        override fun isEmpty(): Boolean {
            return count == 0
        }
    }

    /**
     * Interface for a callback to be invoked when an item in this view has been selected.
     */
    interface OnItemSelectedListener {
        /**
         * Callback method to be invoked when an item in this view has been selected.
         * This callback is invoked only when the newly selected position is different from the
         * previously selected position or if there was no selected item.
         * Implementers can call getItemAtPosition(position) if they need to access the data
         * associated with the selected item.
         *
         * @param [parent] The View where the selection happened.
         * @param [view] The view within the Adapter that was clicked.
         * @param [position] The position of the view in the adapter.
         * @param [id] The row id of the item that is selected.
         */
        fun onItemSelected(parent: MaterialSpinner, view: View?, position: Int, id: Long)

        /**
         * Callback method to be invoked when the selection disappears from this view.
         * The selection can disappear for instance when touch is activated or when the adapter
         * becomes empty.
         *
         * @param [parent] The View that now contains no selected item.
         */
        fun onNothingSelected(parent: MaterialSpinner)
    }

    /**
     * Interface definition for a callback to be invoked when an item in this View has been clicked.
     */
    interface OnItemClickListener {

        /**
         * Callback method to be invoked when an item in this View has been clicked.
         * Implementers can call getItemAtPosition(position) if they need to access the data
         * associated with the selected item.
         *
         * @param [parent] The View where the click happened.
         * @param [view] The view within the adapter that was clicked (this will be a view provided
         * by the adapter).
         * @param [position] The position of the view in the adapter.
         * @param [id] The row id of the item that was clicked.
         */
        fun onItemClick(parent: MaterialSpinner, view: View?, position: Int, id: Long)
    }

    /**
     * Implements some sort of popup selection interface for selecting a spinner option.
     * Allows for different spinner modes.
     */
    private interface SpinnerPopup {

        /**
         * Listener that is called when this popup window is dismissed.
         */
        interface OnDismissListener {
            /**
             * Called when this popup window is dismissed.
             */
            fun onDismiss()
        }

        /**
         * Set hint text to be displayed to the user. This should provide a description of the
         * choice being made.
         *
         * @param [hintText] Hint text to set.
         */
        fun setPromptText(hintText: CharSequence?)

        /**
         * @return The prompt to display when the dialog is shown
         */
        fun getPrompt(): CharSequence?

        /**
         * Sets the adapter that provides the data and the views to represent the data in this popup
         * window.
         *
         * @param [adapter] The adapter to use to create this window's content.
         */
        fun setAdapter(adapter: ListAdapter?)

        /**
         * Show the popup
         */
        fun show(position: Int)

        /**
         * Dismiss the popup
         */
        fun dismiss()

        /**
         * Set a listener to receive a callback when the popup is dismissed.
         *
         * @param [listener] Listener that will be notified when the popup is dismissed.
         */
        fun setOnDismissListener(listener: OnDismissListener?)

        /**
         * Get the data item associated with the specified position in the data set.
         *
         * @param [position] Position of the item whose data we want within the adapter's data set.
         * @return The data at the specified position.
         */
        fun getItem(position: Int): Any?

        /**
         * Get the row id associated with the specified position in the list.
         *
         * @param [position] The position of the item within the adapter's data set whose row id we
         * want.
         * @return The id of the item at the specified position.
         */
        fun getItemId(position: Int): Long

        /**
         * @return true if the popup is showing, false otherwise.
         */
        fun isShowing(): Boolean


    }

    internal class SavedState : AbsSavedState {
        var selection: Int = INVALID_POSITION
        var isShowingPopup: Boolean = false

        constructor(superState: Parcelable) : super(superState)

        @RequiresApi(Build.VERSION_CODES.N)
        constructor(source: Parcel, loader: ClassLoader?) : super(source, loader) {
            selection = source.readInt()
            isShowingPopup = source.readByte().toInt() != 0
        }

        override fun writeToParcel(dest: Parcel, flags: Int) {
            super.writeToParcel(dest, flags)
            dest.writeInt(selection)
            dest.writeByte((if (isShowingPopup) 1 else 0).toByte())
        }

        override fun toString(): String {
            return "MaterialSpinner.SavedState{" +
                    Integer.toHexString(System.identityHashCode(this)) +
                    " selection=" +
                    selection +
                    ", isShowingPopup=" +
                    isShowingPopup +
                    "}"
        }

        companion object CREATOR : Parcelable.ClassLoaderCreator<SavedState> {

            @RequiresApi(Build.VERSION_CODES.N)
            override fun createFromParcel(parcel: Parcel): SavedState {
                return SavedState(parcel, null)
            }

            @RequiresApi(Build.VERSION_CODES.N)
            override fun createFromParcel(parcel: Parcel, loader: ClassLoader): SavedState {
                return SavedState(parcel, loader)
            }

            override fun newArray(size: Int): Array<SavedState?> {
                return arrayOfNulls(size)
            }
        }
    }
}